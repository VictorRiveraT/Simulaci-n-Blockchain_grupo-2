<!doctype html>
<html lang="es" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blockchain Simulator — ECDSA & PoW</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}"> 

  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

  <script>
    const EC = elliptic.ec;
    const ec = new EC('secp256k1');

    // --- INICIO CÓDIGO WEBSOCKETS (Adoptado de Jander) ---
    const socket = io();
    socket.on('connect', () => {
        console.log("Conectado en Tiempo Real");
        setBadge(true, '(EN VIVO)');
    });

    // Cuando llega una nueva transacción, actualizamos el mempool
    socket.on('actualizacion_mempool', (data) => {
        console.log("Evento: " + data.msg);
        document.getElementById('btnShowMempool').click();
    });

    // Cuando se mina un bloque, actualizamos TODO
    socket.on('bloque_minado', (data) => {
        console.log(`BLOQUE #${data.index} MINADO!`);
        // Actualizamos todas las tablas
        document.getElementById('btnBalances').click();
        document.getElementById('btnLeaders').click();
        document.getElementById('btnChain').click();
        document.getElementById('btnShowMempool').click();
        
        // Efecto visual en el badge
        const b = document.getElementById('statusBadge');
        b.textContent = `¡NUEVO BLOQUE #${data.index}!`;
        b.style.backgroundColor = '#10b981';
        b.style.color = 'black';
        setTimeout(() => setBadge(true, '(EN VIVO)'), 3000);
    });
    // --- FIN CÓDIGO WEBSOCKETS ---


    // --- INICIO LÓGICA DE SIMULADOR (Tu Versión) ---
    let aliasCache = {}; 
    let reverseAliasCache = {}; 
    
    // Funciones de Hashing y Cripto (sin cambios)
    const stableStringify = (v) => {
      if (v === null || typeof v !== 'object') return JSON.stringify(v);
      if (Array.isArray(v)) return '[' + v.map(stableStringify).join(',') + ']';
      const keys = Object.keys(v).sort();
      return '{' + keys.map(k => JSON.stringify(k)+':'+stableStringify(v[k])).join(',') + '}';
    };

    const hashPayload = (payload) => {
        const payloadCopy = { ...payload };
        delete payloadCopy.signature;
        const s = stableStringify(payloadCopy);
        return sha256(s);
    };

    const generateKeyPair = () => {
        const key = ec.genKeyPair();
        const privateKeyHex = key.getPrivate('hex');
        // El formato sin comprimir, es el que acepta la verificación en Python (al inicio con '04')
        const publicKeyHex = '04' + key.getPublic('hex'); 
        return { privateKeyHex, publicKeyHex };
    };

    const signTransaction = (privateKeyHex, payload) => {
        try {
            const key = ec.keyFromPrivate(privateKeyHex, 'hex');
            const payloadHash = hashPayload(payload);
            const signature = key.sign(payloadHash, 'hex');
            // La firma debe ser en formato DER para la verificación en Python
            return signature.toDER('hex'); 
        } catch (e) {
            console.error("Error signing:", e);
            return "";
        }
    };
    
    const pubToAddress = (publicKeyHex) => {
        if (!publicKeyHex) return "";
        
        // Casos especiales del sistema
        if (publicKeyHex === 'SYSTEM') return 'SYSTEM';
        
        // 1. Buscar si tiene Alias
        const alias = reverseAliasCache[publicKeyHex];
        
        // 2. Recortar la llave (quitamos el prefijo '04' para el recorte)
        const shortKey = publicKeyHex.substring(2, 10) + '...' + publicKeyHex.substring(publicKeyHex.length - 6);

        // 3. LÓGICA VISUAL: Mostrar Alias (Llave)
        if (alias) {
            // Si es el Founder
            if (alias === "FOUNDER") {
                return `<span style="color:#fcd34d; font-weight:bold;">${alias}</span> <code style="opacity:0.7; font-size:0.9em">(${shortKey})</code>`;
            }
            // Usuario normal: Muestra "Alias (Llave...)"
            return `<span style="color:#4ade80; font-weight:bold;">${alias}</span> <code style="opacity:0.7; font-size:0.9em">(${shortKey})</code>`;
        }
        
        // Si no tiene alias, solo muestra la llave
        return `<code style="opacity:0.8">${shortKey}</code>`;
    };

    // Funciones de UI/Log/API (sin cambios, usando la API como base)
    const log = (obj, title) => {
      const el = document.getElementById('log');
      const prev = el.innerHTML;
      const now = `<pre><code>${title ? '▶ ' + title + '\n' : ''}${typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2)}</code></pre>`;
      el.innerHTML = now + '\n' + prev;
    };
    const setBadge = (ok, extra='') => {
      const b = document.getElementById('statusBadge');
      if (ok) { b.textContent = 'Status: OK ' + extra; b.style.color = '#86efac'; b.style.backgroundColor = '#16a34a';}
      else { b.textContent = 'Status: ERROR ' + extra; b.style.color = '#fca5a5'; b.style.backgroundColor = '#b91c1c';}
    };
    const api = (path, opts={}) =>
      fetch(path, { headers: { 'Content-Type':'application/json' }, ...opts })
        .then(async r => {
          const data = await r.json().catch(()=>({raw:'(sin JSON)'}));
          if (!r.ok) throw { status: r.status, data };
          return data;
        });
        
    const updateAliasCaches = async () => {
        try {
            const data = await api('/aliases');
            aliasCache = data;
            reverseAliasCache = {}; 
            for (const [alias, pubkey] of Object.entries(data)) {
                reverseAliasCache[pubkey] = alias;
            }
            log(aliasCache, 'Alias Sincronizados');
        } catch (e) {
            log(e, 'ERROR /aliases');
        }
    };
        
    const renderTable = (title, dataObj, containerId, valueLabel='Valor') => {
      const container = document.getElementById(containerId);
      const entries = Object.entries(dataObj || {});
      if (!entries.length) {
        container.innerHTML = `<div class="muted">Sin datos por ahora.</div>`;
        return;
      }
      const rows = entries
        .map(([k,v],i) => {
            const displayValue = Number(v); 
            const displayName = pubToAddress(k);
            return `
              <tr>
                <td style="width:56px;">#${i+1}</td>
                <td><code>${displayName}</code></td>
                <td style="text-align:right">${displayValue}</td>
              </tr>
            `;
        }).join('');
      container.innerHTML = `
        <div class="muted" style="margin:6px 0 8px 0;">${title}</div>
        <table class="table">
          <thead>
            <tr><th>#</th><th>Address (Alias / Public Key)</th><th style="text-align:right">${valueLabel}</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    };

    const renderMempool = (transactions, containerId='mempoolResults') => {
      const container = document.getElementById(containerId);
      if (transactions.length === 0) {
        container.innerHTML = '<div class="mempool-empty">El Mempool está vacío.</div>';
        return;
      }

      const rows = transactions.map((tx, i) => {
        const displayAmount = Number(tx.amount);
        const senderName = pubToAddress(tx.sender);
        const recipientName = pubToAddress(tx.recipient);
        const time = tx.timestamp ? new Date(tx.timestamp * 1000).toLocaleTimeString() : 'N/A';

        return `
            <tr>
                <td style="width: 30px;">#${i + 1}</td>
                <td style="width: 100px; text-align:right;">${displayAmount}</td>
                <td><code>${senderName}</code></td>
                <td><code>${recipientName}</code></td>
                <td>${time}</td>
            </tr>
        `;
      }).join('');

      container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th style="text-align:right;">Monto</th>
                        <th>Remitente</th>
                        <th>Destinatario</th>
                        <th>Hora</th>
                    </tr>
                </thead>
                <tbody>${rows}</tbody>
            </table>
        `;
    };
    
    let lastVerifiedTransaction = null; 

    // Funciones de control de la UI 
    window.addEventListener('load', () => {
        
        document.getElementById('btnRandomKeys').onclick = async () => {
            const alias = document.getElementById('alias').value;
            if (!alias) {
                log("ERROR: Debes escribir un Alias (nombre) para registrar.", 'Error de Registro');
                return;
            }
            
            log("Generando llaves y registrando alias...");
            const { privateKeyHex, publicKeyHex } = generateKeyPair();
            if (!privateKeyHex || !publicKeyHex) { 
                log("ERROR: La generación de claves falló.", 'Error de Criptografía');
                return;
            }
            
            document.getElementById('privateKey').value = privateKeyHex;
            document.getElementById('publicKey').value = publicKeyHex;
            document.getElementById('sender_pub_tx').value = publicKeyHex; 
            document.getElementById('miner_address').value = publicKeyHex; 
            log({ alias, privateKeyHex, publicKeyHex }, 'Llaves Generadas');
            
            try {
                const regData = await api('/register_alias', {
                    method: 'POST',
                    body: JSON.stringify({ alias: alias, public_key: publicKeyHex })
                });
                log(regData, 'Alias Registrado');
                await updateAliasCaches();
                document.getElementById('btnBalances').click();
            } catch (e) {
                log(e.data, 'ERROR de Registro de Alias');
            }
            
            document.getElementById('signature_node').value = '';
            document.getElementById('publickey_node').value = '';
            document.getElementById('btnSendToMempool').disabled = true;
            document.getElementById('validationCard').classList.remove('valid', 'invalid');
            lastVerifiedTransaction = null;
        };

        document.getElementById('btnSignTx').onclick = () => {
            const privateKeyHex = document.getElementById('privateKey').value;
            const senderPub = document.getElementById('sender_pub_tx').value;
            let recipient = document.getElementById('recipient_tx').value;
            
            const amount_input = parseFloat(document.getElementById('amount_tx').value || '0');
            const amount_int = Math.round(amount_input); 

            if (!privateKeyHex || !senderPub) {
                log("ERROR: Debes generar y seleccionar las Llaves primero.", 'Error de Firma');
                return;
            }
            
            // Resolución de Alias
            if (recipient && !recipient.startsWith('04')) {
                const resolvedKey = aliasCache[recipient];
                if (resolvedKey) {
                    log(`Alias "${recipient}" resuelto a ${resolvedKey.substring(0, 20)}...`);
                    recipient = resolvedKey;
                } else {
                    log(`ERROR: Alias "${recipient}" no encontrado.`, 'Error de Firma');
                    return;
                }
            }
            
            if (!recipient || amount_int <= 0) {
                log("ERROR: Monto debe ser positivo y Destinatario (o alias) válido.", 'Error de Firma');
                return;
            }

            const payload = {
                amount: amount_int, 
                recipient: recipient, 
                sender: senderPub,
            };
            
            const signature = signTransaction(privateKeyHex, payload);
            document.getElementById('signature_tx').value = signature;
            log({ payload, signature, hash: hashPayload(payload) }, 'Transacción Firmada');

            document.getElementById('signature_node').value = signature;
            document.getElementById('publickey_node').value = senderPub;
            document.getElementById('btnSendToMempool').disabled = true; 
            document.getElementById('validationCard').classList.remove('valid', 'invalid');
            lastVerifiedTransaction = null;
        };
        
        const validationCard = document.getElementById('validationCard');
        const btnSendToMempool = document.getElementById('btnSendToMempool');
        btnSendToMempool.disabled = true; 

        document.getElementById('btnVerifyTxNode').onclick = async () => {
            const sender_pub = document.getElementById('sender_pub_tx').value;
            let recipient = document.getElementById('recipient_tx').value;
            
            const amount_input = parseFloat(document.getElementById('amount_tx').value || '0');
            const amount_int = Math.round(amount_input);

            const signature = document.getElementById('signature_node').value;
            const publickey_for_verification = document.getElementById('publickey_node').value;

            // Resolución de Alias
            if (recipient && !recipient.startsWith('04')) {
                const resolvedKey = aliasCache[recipient];
                if (resolvedKey) {
                    log(`Alias "${recipient}" resuelto a ${resolvedKey.substring(0, 20)}...`);
                    recipient = resolvedKey;
                } else {
                    log(`ERROR: Alias "${recipient}" no encontrado.`, 'Error de Verificación');
                    validationCard.classList.add('invalid');
                    btnSendToMempool.disabled = true;
                    return;
                }
            }

            if (!sender_pub || !signature || !recipient || amount_int <= 0 || !publickey_for_verification) {
                log("ERROR: Rellenar todos los campos de Tx, Public Key y Firma.", 'Error de Verificación');
                validationCard.classList.remove('valid');
                validationCard.classList.add('invalid');
                btnSendToMempool.disabled = true;
                return;
            }

            try {
                const verificationResult = await api('/transactions/verify_only', {
                    method: 'POST',
                    body: JSON.stringify({ 
                        sender_pub: publickey_for_verification, 
                        recipient: recipient,
                        amount: amount_int,
                        signature: signature,
                    })
                });

                if (verificationResult && verificationResult.valid) {
                    log("VERIFICACIÓN EXITOSA (BACKEND): Firma válida y fondos suficientes.", 'Verificación Exitosa');
                    validationCard.classList.remove('invalid');
                    validationCard.classList.add('valid');
                    btnSendToMempool.disabled = false;
                    lastVerifiedTransaction = { sender_pub: publickey_for_verification, recipient, amount: amount_int, signature: signature };

                } else {
                    log(verificationResult.error || "VERIFICACIÓN FALLIDA: Fondos insuficientes o error en el backend.", 'Verificación Fallida');
                    validationCard.classList.remove('valid');
                    validationCard.classList.add('invalid');
                    btnSendToMempool.disabled = true;
                }

            } catch (e) {
                log(e.data?.error || "VERIFICACIÓN FALLIDA: Error al comunicarse con el nodo.", 'Verificación Fallida');
                validationCard.classList.remove('valid');
                validationCard.classList.add('invalid');
                btnSendToMempool.disabled = true;
            }
        };

        document.getElementById('btnSendToMempool').onclick = async () => {
            if (!lastVerifiedTransaction) {
                log("ERROR: Primero debes verificar la transacción.", 'Error de Envío');
                return;
            }
            
            try { 
                const d = await api('/transactions/new', { 
                    method:'POST', 
                    body: JSON.stringify(lastVerifiedTransaction) 
                }); 
                log(d, 'Transacción Añadida al Mempool');
                document.getElementById('btnShowMempool').click();
                document.getElementById('btnBalances').click();
                
                btnSendToMempool.disabled = true;
                validationCard.classList.remove('valid', 'invalid');
                lastVerifiedTransaction = null;

            } catch (e) { 
                log(e.data?.error || e, 'ERROR al enviar al Mempool'); 
                document.getElementById('btnBalances').click();
            }
        };

        document.getElementById('btnMine').onclick = async () => {
            const miner_address = document.getElementById('miner_address').value;
            if (!miner_address) {
                log("ERROR: La dirección del minero no puede estar vacía.", 'Error de Minado');
                return;
            }
            const t0 = performance.now();
            try { 
                const d = await api('/mine', { method:'POST', body: JSON.stringify({ miner_address }) }); 
                const t1 = performance.now(); 
                log({ tiempo_ms: Math.round(t1-t0), ...d }, 'Bloque Minado'); 

                document.getElementById('blockIndex').textContent = d.index;
                document.getElementById('blockNonce').textContent = d.nonce;
                document.getElementById('blockPrevHash').textContent = d.previous_hash;
                document.getElementById('blockHash').textContent = d.hash;

                const txListEl = document.getElementById('blockTxsList');
                if (d.transactions && d.transactions.length > 0) {
                    txListEl.innerHTML = d.transactions.map((tx, i) => 
                        `<p class="muted" style="font-size:11px; margin: 4px 0;">
                            <b>Tx #${i}:</b> ${tx.amount} 
                            (De: ${pubToAddress(tx.sender)} 
                            -> A: ${pubToAddress(tx.recipient)})
                        </p>`
                    ).join('');
                } else {
                    txListEl.innerHTML = '<p class="muted">No hay transacciones en este bloque.</p>';
                }

                document.getElementById('btnChain').click();
                document.getElementById('btnLeaders').click();
                document.getElementById('btnBalances').click();
                document.getElementById('btnShowMempool').click(); 

            } catch (e) { 
                log(e.data?.error || e, 'ERROR /mine'); 
            }
        };

        document.getElementById('btnHealth').onclick = async () => {
          try { 
            const d = await api('/health'); 
            setBadge(true, `(diff=4, len=${d.chain_length}, pend=${d.mempool_size})`); 
            log(d, '/health'); 
          }
          catch (e) { setBadge(false); log(e.data?.error || e, 'ERROR /health'); }
        };
        document.getElementById('btnChain').onclick = async () => { try { log(await api('/chain'), '/chain'); } catch(e){ log(e.data?.error || e,'ERROR /chain'); } };
        document.getElementById('btnValidate').onclick = async () => { 
          try { 
            const d = await api('/validate');
            log(d, '/validate'); 
            if (!d.valid) setBadge(false, '(CADENA INVÁLIDA)');
          } catch(e){ log(e.data?.error || e,'ERROR /validate'); } 
        };
        
        document.getElementById('btnLeaders').onclick = async () => {
          try { 
            await updateAliasCaches();
            const d = await api('/leaders');
            log(d, '/leaders (Ranking)');                 
            renderTable('Recompensas acumuladas por minero', d, 'leadersTable', 'Recompensa');
          } catch (e) { log(e.data?.error || e, 'ERROR /leaders'); }
        };
        document.getElementById('btnBalances').onclick = async () => {
          try { 
            await updateAliasCaches();
            const d = await api('/balances');
            log(d, '/balances (Saldos)');
            renderTable('Saldo neto por address (Public Key)', d, 'balancesTable', 'Saldo');
          } catch (e) { log(e.data?.error || e, 'ERROR /balances'); }
        };
        document.getElementById('btnShowMempool').onclick = async () => { 
            try { 
                await updateAliasCaches();
                const d = await api('/mempool'); 
                renderMempool(d, 'mempoolResults'); 
                log(d, '/mempool (Transacciones Pendientes)'); 
            } catch(e) { log(e.data?.error || e,'ERROR /mempool'); } 
        };

        document.getElementById('btn_faucet_send').onclick = async () => {
            const recipient = document.getElementById('faucet_recipient').value;
            const private_key = document.getElementById('faucet_private_key').value;
            let recipient_address = recipient;

            if (!recipient_address || !private_key) {
                log("ERROR: Debes poner un Destinatario Y la Llave Privada del Fundador.", 'Error de Faucet');
                return;
            }

            // Resolución de Alias (sólo si no parece ser una llave)
            if (!recipient_address.startsWith('04')) {
                const resolvedKey = aliasCache[recipient_address];
                if (resolvedKey) {
                    log(`Alias "${recipient_address}" resuelto a ${resolvedKey.substring(0, 20)}...`);
                    recipient_address = resolvedKey;
                } else {
                    log(`ERROR: Alias "${recipient_address}" no encontrado.`, 'Error de Faucet');
                    return;
                }
            }
            
            log(`Enviando 100 monedas del Faucet a ${pubToAddress(recipient_address)}...`);
            try {
                const d = await api('/faucet', { 
                    method:'POST', 
                    body: JSON.stringify({ 
                        recipient_address: recipient_address,
                        admin_private_key: private_key
                    }) 
                });
                log(d, 'Faucet');
                document.getElementById('btnShowMempool').click();
                document.getElementById('btnBalances').click();
            } catch (e) {
                log(e.data, 'ERROR /faucet');
            }
        };

        const init = async () => {
            await updateAliasCaches();
            document.getElementById('btnHealth').click();
            document.getElementById('btnBalances').click();
        };
        init();
    });
  </script>
  <style>
    /* Estilos mínimos para que se vea decente */
    :root { --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#9ca3af; --accent:#22c55e; --danger:#ef4444; --border:#1f2937; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; background: var(--bg); color: var(--text); }
    header { padding: 24px; border-bottom:1px solid var(--border); position: sticky; top:0; background: linear-gradient(180deg, #0f172a 0%, rgba(15,23,42,.9) 100%); backdrop-filter: blur(6px); z-index: 100; }
    main { max-width: 1400px; margin: 24px auto; padding: 0 16px 48px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
    .col-span-3 { grid-column: span 3; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    h2 { margin-top: 0; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-bottom: 15px;}
    label { display: block; font-size: 0.9em; color: var(--muted); margin-bottom: 4px; }
    input, textarea { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); margin-bottom: 10px; resize: vertical; font-family: monospace;}
    .btn { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; background: #334155; color: var(--text); font-weight: bold; transition: background 0.2s; }
    .btn:hover { background: #475569; }
    .btn.primary { background: var(--accent); color: black; }
    .btn.primary:hover { background: #14b8a6; }
    .row { display: flex; gap: 16px; align-items: stretch; }
    .row > div { flex: 1; }
    .grid-4 { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; }
    .log { background: #000; color: #ccc; padding: 10px; border-radius: 4px; height: 300px; overflow-y: scroll; font-size: 0.85em; border: 1px solid var(--border); }
    pre { margin: 0; padding: 0; white-space: pre-wrap; word-break: break-all; }
    code { background: #1e293b; padding: 2px 4px; border-radius: 3px; font-size: 0.9em; }
    .table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    .table th, .table td { padding: 8px; border-bottom: 1px solid var(--border); }
    .table th { text-align: left; color: #a3a3a3; }
    .table tbody tr:last-child td { border-bottom: none; }
    .muted { color: var(--muted); font-size: 0.9em; }
    .badge { padding: 4px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; background: #334155; color: var(--muted); }
    
    /* Estados de Validación */
    .validation-card { border: 1px solid #1f2937; }
    .validation-card.valid { border-color: var(--accent); box-shadow: 0 0 10px rgba(34, 197, 94, 0.4); }
    .validation-card.invalid { border-color: var(--danger); box-shadow: 0 0 10px rgba(239, 68, 68, 0.4); }
    .validation-card .btn.primary { opacity: 0.5; cursor: not-allowed; }
    .validation-card.valid .btn.primary { opacity: 1; cursor: pointer; }

    .faucet-card { border-left: 5px solid #06b6d4; }
  </style>
</head>
<body>
  <header>
    <div style="display: flex; align-items: center; justify-content: space-between; max-width: 1400px; margin: 0 auto;">
      <div style="display: flex; align-items: center; gap: 12px;">
        <div style="font-size: 24px; color: #fcd34d;">B</div>
        <h1>Blockchain Simulator</h1>
        <span class="badge" id="statusBadge">Status: ...</span>
      </div>
      <div class="subtitle" style="color: var(--muted); font-size: 0.9em;">Sistema descentralizado con ECDSA y Proof of Work</div>
    </div>
  </header>

  <main>
    <section class="card">
      <h2>1. Generación de Identidad</h2>
      
      <label>Alias (Tu nombre de usuario)</label>
      <input id="alias" placeholder="Ej: victor, satoshi, ..." />
      <div style="height:10px"></div>
      
      <label>Llave Privada (Private Key - ¡Secreta!)</label>
      <input id="privateKey" placeholder="Se generará al registrar el alias..." readonly/>
      <div style="height:10px"></div>
      <label>Llave Pública (Public Key - Dirección)</label>
      <textarea id="publicKey" rows="3" placeholder="Se generará al registrar el alias..." readonly></textarea>
      <div style="height:10px"></div>
      
      <button class="btn primary" id="btnRandomKeys">GENERAR Y REGISTRAR ALIAS</button>
      
    </section>

    <section class="card">
      <h2>2. Creación y Firma de Transacción</h2>
      <label>Remitente (sender_pub - Copia la Public Key de arriba)</label>
      <textarea id="sender_pub_tx" rows="2" placeholder="Llave Pública COMPLETA del remitente (FROM)"></textarea>
      <div style="height:10px"></div>
      
      <label>Destinatario (recipient)</label>
      <input id="recipient_tx" placeholder="Alias o Llave Pública de otro usuario (TO)" value="FOUNDER" />
      <div style="height:10px"></div>
      
      <label>Monto (amount)</label>
      <input id="amount_tx" type="number" step="1" placeholder="10" value="10" /> 
      
      <div style="height:10px"></div>
      <button class="btn" id="btnSignTx">FIRMAR TRANSACCIÓN</button>
      <div style="height:10px"></div>
      <label>Firma de Transacción (Message Signature)</label>
      <textarea id="signature_tx" rows="2" placeholder="Se genera al firmar el payload..." readonly></textarea>
    </section>

    <section class="card validation-card" id="validationCard">
      <h2>3. Verificación de Firma y Fondos</h2>
      <div class="muted">
        El Nodo Central verifica la autenticidad (firma) y la disponibilidad de fondos antes de aceptar una transacción.
      </div>
      <div style="height:16px"></div>

      <label>Firma del Mensaje (Message Signature)</label>
      <textarea id="signature_node" rows="2" placeholder="Copia la firma de la sección anterior"></textarea>
      <div style="height:10px"></div>
      <label>Llave Pública del Remitente (Public Key)</label>
      <textarea id="publickey_node" rows="2" placeholder="Copia la Public Key del Remitente"></textarea>
      <div style="height:10px"></div>

      <div class="row" style="gap: 10px;">
          <button class="btn" id="btnVerifyTxNode">VERIFICAR</button>
          <button class="btn primary" id="btnSendToMempool">ENVIAR AL MEMPOOL</button>
      </div>
    </section>
    
    <div class="card col-span-3" style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; padding: 24px;">
        
        <div class="card" style="margin: 0; padding: 20px;">
            <h2>4. Mempool - Transacciones Pendientes</h2>
            <div class="muted" style="margin-bottom: 12px;">
                Transacciones válidas esperando ser incluidas en el próximo bloque por un minero.
            </div>
            <button class="btn" id="btnShowMempool">VER MEMPOOL ACTUAL</button>
            <div style="margin-top: 15px;">
                <div id="mempoolResults">
                    <div class="muted">Haz clic en "Ver Mempool Actual" para ver transacciones pendientes.</div>
                </div>
            </div>
        </div>

        <div class="card" style="margin: 0; padding: 20px;">
            <h2>5. Proceso de Minado</h2>
            <label>Dirección del minero (Alias o Public Key)</label>
            <textarea id="miner_address" rows="2" placeholder="Pega aquí tu Alias o Public Key para recibir la recompensa..."></textarea>
            <div style="height:10px"></div>
            <button class="btn primary" id="btnMine">MINAR BLOQUE (PoW)</button>
            <div style="height:20px"></div>

            <h3>Bloque Candidato (Resultado)</h3>
            <div class="muted">
                Haz clic en MINAR para calcular el hash del siguiente bloque.
            </div>
            
            <div id="blockCandidateDisplay" class="block-display">
                <p><strong>Bloque N°:</strong> <span id="blockIndex">...</span></p>
                <p><strong>Nonce encontrado:</strong> <span id="blockNonce">...</span></p>
                <p><strong>Prev Hash:</strong> <code id="blockPrevHash">...</code></p>
                <hr>
                <h4>Transacciones (Mempool incluido):</h4>
                <div id="blockTxsList">
                    <p class="muted">Carga el Mempool para ver el contenido a minar.</p>
                </div>
                <hr>
                <p><strong>HASH VÁLIDO:</strong> <code id="blockHash">...</code></p>
            </div>
        </div>
    </div>

    <section class="card col-span-3">
      <h2>6. Resumen Económico (Validado por la Cadena)</h2>
      <div class="row">
        <div><div id="leadersTable"></div></div>
        <div><div id="balancesTable"></div></div>
      </div>
    </section>
    
    <section class="card col-span-3">
      <h2>7. Panel de Resultados / Log</h2>
      <div class="log" id="log"></div>
    </section>

    <section class="card col-span-3 faucet-card">
        <h2>Faucet del Fundador (Admin)</h2>
        <div class="muted">
          Aquí el Fundador puede "empujar" fondos a cualquier usuario.
          (Necesitas la Llave Privada del Fundador que se muestra en la consola del servidor).
        </div>
        <div style="height:16px"></div>
  
        <label>Destinatario (Alias o Llave Pública)</label>
        <input id="faucet_recipient" placeholder="Ej: victor (o la llave 04...)" />
        <div style="height:10px"></div>

        <label>Llave Privada del Fundador (Admin)</label>
        <textarea id="faucet_private_key" rows="2" placeholder="Copiar de la consola del servidor..." autocomplete="off"></textarea>
        <div style="height:10px"></div>
        
        <button class="btn" id="btn_faucet_send">
            ENVIAR 100 (desde Fundador)
        </button>
    </section>

    <section class="card col-span-3">
      <h2>8. Consultas de Cadena</h2>
      <div class="grid-4">
        <button class="btn" id="btnHealth">/HEALTH</button>
        <button class="btn" id="btnChain">/CHAIN</button>
        <button class="btn" id="btnValidate">/VALIDATE</button>
        <button class="btn" id="btnLeaders">/LEADERS</button>
        <button class="btn" id="btnBalances">/BALANCES</button>
      </div>
    </section>
  </main>

  <div class="footer" style="text-align: center; color: var(--muted); font-size: 0.8em; padding: 20px;">
    Blockchain Simulator con ECDSA y Proof of Work - Requiere Flask backend
  </div>
</body>
</html>
